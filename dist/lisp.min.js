const t="ident",e="(",r=")",n="expr",u={type:"nil"},a=/^-?[0-9][0-9]*\.?[0-9]*$/,l=/^\s$/,s=e=>{let r=(e=>p?e?{type:e,value:p}:a.test(p)?{type:"num",value:parseFloat(p)}:"true"==p||"false"==p?{type:"bool",value:"true"==p}:{type:t,value:p}:null)(e);return r&&(p=""),r};let p="",i=!1;const y=async(e,r=[])=>{if(!e)return u;let a;const l=(t,e)=>r.slice(e).find((e=>e[t]))?.[t],s=t=>y(t,[{},...r]);if(e.type===n){const[t,...n]=e.args,p=await s(t);return p?.call?(a={stack:r,args:n,get:l,val:s},await p(a)??u):p}return e.type===t?l(e.value):e},f=(t,u)=>{return y((t=>{let u=0,a=t[u];const l=e=>{const r=a;return a=t[++u],r},s=()=>{l();const t=[];for(;a.type!==r;)t.push(a.type===e?s():l(a.type));return l(),{type:n,args:t}};return s()})((a=t,[...a].map((t=>{if(i){if('"'==t)return i=!1,s("str")}else{if('"'==t)return i=!0,s();if(t==e)return[s(),{type:e}];if(t==r)return[s(),{type:r}];if(l.test(t))return s()}p+=t})).flat(1/0).filter((t=>t)))),u);var a};export{f as run,y as evaluate};
