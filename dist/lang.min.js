let e="ident",t="expr",a={type:"nil"},l=/^-?[0-9][0-9]*\.?[0-9]*$/,r=/^\s$/,p=null,u="",s=0,y=t=>{let a=(t=>u?t?{type:t,value:u}:l.test(u)?{type:"num",value:parseFloat(u)}:/^(true|false)$/.test(u)?{type:"bool",value:"true"==u}:{type:e,value:u}:p)(t);return a&&(u=""),a},n=e=>[...e].map((e=>s?'"'==e?(s=0,y("str")):(u+=e,p):'"'==e?(s=1,y()):"("==e?[y(),{type:"("}]:")"==e?[y(),{type:")"}]:r.test(e)?y():(u+=e,p))).flat(1/0).filter((e=>e)),i=e=>{let a=0,l=e[a],r=()=>(l=e[a+1],e[a++]),p=()=>{let e=[];for(r();")"!==l.type;)e.push("("===l.type?p():r(l.type));return r(),{type:t,args:e}};return p()},f=async(l,r=[])=>{if(!l)return a;let p,u=(e,t)=>r.slice(t).find((t=>t[e]))?.[e],s=e=>f(e,[{},...r]),y=async e=>(await s(e)).value;if(l.type===t){let[e,...t]=l.args,n=await s(e);return n?.call?(p={stack:r,args:t,get:u,val:s,raw:y},await n(p)??a):n}return l.type===e?u(l.value):l},v=(e,t)=>f(i(n(e)),t);export{v as run,i as parse,n as tokenize,f as evaluate};
