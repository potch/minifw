const t="ident",e="expr",r={type:"nil"},n=/^-?[0-9][0-9]*\.?[0-9]*$/,u=/^\s$/,a=e=>{let r=(e=>l?e?{type:e,value:l}:n.test(l)?{type:"num",value:parseFloat(l)}:"true"==l||"false"==l?{type:"bool",value:"true"==l}:{type:t,value:l}:null)(e);return r&&(l=""),r};let l="",s=0;const p=async(n,u=[])=>{if(!n)return r;let a;const l=(t,e)=>u.slice(e).find((e=>e[t]))?.[t],s=t=>p(t,[{},...u]);if(n.type===e){const[t,...e]=n.args,p=await s(t);return p?.call?(a={stack:u,args:e,get:l,val:s},await p(a)??r):p}return n.type===t?l(n.value):n},i=(t,r)=>{return p((t=>{let r=0,n=t[r];const u=e=>{const u=n;return n=t[++r],u},a=()=>{u();const t=[];for(;")"!==n.type;)t.push("("===n.type?a():u(n.type));return u(),{type:e,args:t}};return a()})((n=t,[...n].map((t=>{if(s){if('"'==t)return s=0,a("str")}else{if('"'==t)return s=1,a();if("("==t)return[a(),{type:"("}];if(")"==t)return[a(),{type:")"}];if(u.test(t))return a()}l+=t})).flat(1/0).filter((t=>t)))),r);var n};export{i as run,p as evaluate};
