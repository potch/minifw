let e="ident",t="expr",l={type:"nil"},r=/^-?[0-9][0-9]*\.?[0-9]*$/,a=/^\s$/,p=null,u="",s=0,n=t=>{let l=(t=>u?t?{type:t,value:u}:r.test(u)?{type:"num",value:parseFloat(u)}:/^(true|false)$/.test(u)?{type:"bool",value:"true"==u}:{type:e,value:u}:p)(t);return l&&(u=""),l},y=e=>[...e].map((e=>s?'"'==e?(s=0,n("str")):(u+=e,p):'"'==e?(s=1,n()):"("==e?[n(),{type:"("}]:")"==e?[n(),{type:")"}]:a.test(e)?n():(u+=e,p))).flat(1/0).filter((e=>e)),i=e=>{let l=0,r=e[l],a=()=>(r=e[l+1],e[l++]),p=()=>{let e=[];for(a();")"!==r.type;)e.push("("===r.type?p():a(r.type));return a(),{type:t,args:e}};return p()},f=async(r,a=[])=>{if(!r)return l;let p=(e,t)=>a.slice(t).find((t=>t[e]))?.[e],u=e=>f(e,[{},...a]),s=e=>u(e).then((e=>e.value)),{type:n,value:y,args:i}=r;if(n===t){let e=await u(i[0]);return e?.call?await e({stack:a,args:i.slice(1),get:p,val:u,raw:s})??l:e}return n===e?p(y):r},v=(e,t)=>f(i(y(e)),t);export{v as run,i as parse,y as tokenize,f as evaluate};
